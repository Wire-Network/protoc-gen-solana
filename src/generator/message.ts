import { protoNameToRust } from "../util/names.js"
import { log } from "../util/logger.js"
import {
  FieldInfo,
  genStructMember,
  genFieldEncode,
  genFieldDecode
} from "./field.js"
import { PROTO_TYPE_MAP, WireType } from "./type-map.js"

/**
 * Descriptor subset for a protobuf message needed by the codegen.
 */
export interface MessageDescriptor {
  /** Simple name (e.g. "MyMessage") */
  name: string
  /** Fully qualified name (e.g. ".my_package.MyMessage") */
  fullName: string
  /** Field descriptors */
  fields: FieldInfo[]
  /** Nested message descriptors (for map entry types, etc.) */
  nestedMessages: MessageDescriptor[]
  /** True if this message is a synthetic map entry */
  isMapEntry: boolean
}

/**
 * Generate a complete .rs file containing struct definitions and
 * encode/decode impl blocks for all non-map-entry messages
 * in a given proto file.
 */
export function generateRsFile(
  messages: MessageDescriptor[],
  protoFileName: string
): string {
  const lines: string[] = []

  lines.push(`// Auto-generated by protoc-gen-solana from ${protoFileName}`)
  lines.push(`// DO NOT EDIT`)
  lines.push(``)
  lines.push(`#![allow(unused_imports, non_camel_case_types, dead_code)]`)
  lines.push(``)
  lines.push(`use crate::protobuf_runtime::*;`)
  lines.push(``)

  // Generate structs with encode/decode impls
  for (const msg of messages) {
    if (msg.isMapEntry) continue
    lines.push(genStruct(msg))
    lines.push(``)
    lines.push(genImpl(msg))
    lines.push(``)
  }

  return lines.join("\n")
}

/**
 * Generate Rust struct definition for a message.
 */
function genStruct(msg: MessageDescriptor): string {
  const name = protoNameToRust(msg.fullName)
  log.debug(`Generating struct ${name} (${msg.fields.length} fields)`)

  const members = msg.fields
    .filter(f => !isMapEntryField(f, msg))
    .map(f => {
      const mapEntry = resolveMapEntry(f, msg)
      if (mapEntry) {
        return genStructMember({ ...f, mapEntry })
      }
      return genStructMember(f)
    })

  return [
    `#[derive(Clone, Debug, Default, PartialEq)]`,
    `#[cfg_attr(feature = "borsh", derive(borsh::BorshSerialize, borsh::BorshDeserialize))]`,
    `pub struct ${name} {`,
    ...members,
    `}`
  ].join("\n")
}

/**
 * Generate the impl block with encode() and decode() for a message.
 */
function genImpl(msg: MessageDescriptor): string {
  const structName = protoNameToRust(msg.fullName)

  log.debug(`Generating impl ${structName}`)

  const encodeBody = genEncodeFunction(msg, structName)
  const decodeBody = genDecodeFunction(msg, structName)

  return [
    `impl ${structName} {`,
    ``,
    encodeBody,
    ``,
    decodeBody,
    `}`
  ].join("\n")
}

/**
 * Generate the encode function body.
 */
function genEncodeFunction(
  msg: MessageDescriptor,
  structName: string
): string {
  const lines: string[] = []
  lines.push(`    pub fn encode(&self) -> Vec<u8> {`)
  lines.push(`        let mut buf = Vec::new();`)

  for (const field of msg.fields) {
    if (isMapEntryField(field, msg)) continue

    const mapEntry = resolveMapEntry(field, msg)
    const fieldInfo = mapEntry ? { ...field, mapEntry } : field

    lines.push(``)
    lines.push(`        // field ${field.number}: ${field.name}`)
    lines.push(genFieldEncode(fieldInfo))
  }

  lines.push(``)
  lines.push(`        buf`)
  lines.push(`    }`)
  return lines.join("\n")
}

/**
 * Generate the decode function body with tag-dispatch loop.
 */
function genDecodeFunction(
  msg: MessageDescriptor,
  structName: string
): string {
  const lines: string[] = []
  lines.push(
    `    pub fn decode(data: &[u8]) -> Result<Self, DecodeError> {`
  )
  lines.push(`        let mut msg = Self::default();`)
  lines.push(`        let mut pos = 0usize;`)
  lines.push(`        let end = data.len();`)
  lines.push(``)
  lines.push(`        while pos < end {`)
  lines.push(`            let (tag, new_pos) = decode_key(data, pos)?;`)
  lines.push(`            pos = new_pos;`)
  lines.push(``)
  lines.push(`            match tag {`)

  for (const field of msg.fields) {
    if (isMapEntryField(field, msg)) continue

    const mapEntry = resolveMapEntry(field, msg)
    const fieldInfo = mapEntry ? { ...field, mapEntry } : field

    lines.push(genFieldDecode(fieldInfo))
  }

  lines.push(`            _ => {`)
  lines.push(`                pos = skip_field(data, pos, tag & 0x07)?;`)
  lines.push(`            }`)
  lines.push(`            }`)
  lines.push(`        }`)
  lines.push(``)
  lines.push(`        Ok(msg)`)
  lines.push(`    }`)
  return lines.join("\n")
}

// ── Map entry resolution ──────────────────────────────────────────────

interface MapEntryInfo {
  keyType: number
  valueType: number
  valueTypeName?: string
}

/**
 * Check if a field references a map entry message type.
 */
function isMapEntryField(
  field: FieldInfo,
  parentMsg: MessageDescriptor
): boolean {
  if (field.type !== 11 || field.label !== 3) return false
  const nested = parentMsg.nestedMessages.find(
    m => field.typeName?.endsWith(`.${m.name}`)
  )
  return nested?.isMapEntry ?? false
}

/**
 * Resolve a map entry's key/value types from the synthetic nested message.
 */
function resolveMapEntry(
  field: FieldInfo,
  parentMsg: MessageDescriptor
): MapEntryInfo | undefined {
  if (field.type !== 11 || field.label !== 3) return undefined
  const nested = parentMsg.nestedMessages.find(
    m => field.typeName?.endsWith(`.${m.name}`)
  )
  if (!nested?.isMapEntry) return undefined

  const keyField = nested.fields.find(f => f.number === 1)
  const valField = nested.fields.find(f => f.number === 2)
  if (!keyField || !valField) return undefined

  return {
    keyType: keyField.type,
    valueType: valField.type,
    valueTypeName: valField.typeName
  }
}
